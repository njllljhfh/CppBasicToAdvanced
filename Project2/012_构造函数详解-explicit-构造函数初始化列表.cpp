#include <iostream>
#include "012_Time.h"
using namespace std;

void func(int a, int b = 2)
{
    cout << "a = " << a << "  b = " << b << endl;
    return;
}

void func1(Time012 myt) //myt 是临时产生的对象，函数结束后，会被系统回收
{
    
}

int main()
{
    //C++从基础到进阶-视频-12
    cout << "012_构造函数详解-explicit-构造函数初始化列表" << endl;
    /*
        一、构造函数：
            - 在类中，有一个特殊的成员函数，他的名字和类名相同，我们在创建类的对象时，这个特殊的成员函数会被系统自动调用。这个成员函数叫“构造函数”。
            - 因为构造函数会被系统自动调用，可以简单的理解为，构造函数的目的就是初始化类对象的数据成员。
            - 特点：
                1. 构造函数没有返回值（不写void）。
                2. 不可以手动调用构造函数，否则编译就会出错。
                3. 正常情况下，构造函数应该被声明为public。
                    - 因为我们创建一个对象时，系统要替我们调用构造函数，这说明构造函数它是一个public函数，才能被系统（外界）调用。
                    - 因为缺省的成员是私有成员，所以要声明构造函数是一个public函数，否则就无法直接创建该类对象。
                4. 构造函数中如果有多个参数，则创建对象时也要带上这些参数。
    */
    cout << "一、构造函数" << endl;
    Time012 myTime = Time012(12, 13, 52);  //创建对象
    Time012 myTime2(12, 13, 52);
    Time012 myTime3 = Time012{ 12,13,52 };
    Time012 myTime4{ 12,13,52 };
    //Time012 myTime5 = { 12,13,52 }; //隐式类型转换（构造函数加了explicit，就不能使用隐式类型转换的写法来初始化对象了）
    //Time012 myTime6(); //警告
    //Time012 myTime7(12,13); //错误
    cout << "----------" << endl;

    cout << "-------------------------------------------------------" << endl;

    /*
        二、多个构造函数：
            - 一个类中可以有多个构造函数，就可以为类对象的创建提供多种初始化方法。但是多个构造函数之间总要有点不同的地方（比如参数数量）。
    */
    cout << "二、多个构造函数" << endl;
    Time012 myTime10 = Time012();  //创建对象
    //Time012 myTime2(); //这么写有问题
    Time012 myTime12;
    Time012 myTime13 = Time012{};
    Time012 myTime14{};
    Time012 myTime15 = {}; //隐式类型转换
    cout << "----------" << endl;

    cout << "对象拷贝" << endl;
    Time012 myTime20;
    //以下4个对象，并没有调用传统意义上的构造函数，他们调用的是 拷贝构造函数（后续会讲）。
    Time012 myTime22 = myTime20;
    Time012 myTime23(myTime20);
    Time012 myTime24{ myTime20 };
    Time012 myTime25 = { myTime20 };
    cout << "-------------------------------------------------------" << endl;

    /*
        三、函数默认参数
            - 规定：
                1. 默认值只能放在函数声明中，除非该函数没有函数声明。
                2. 在具有多个参数的函数中指定默认值时，默认参数都必须出现在非默认参数的右边，一旦某个参数开始指定默认参数，它右边的参数必须指定默认值。

    */
    cout << "三、函数默认参数" << endl;
    Time012 myTime30 = Time012(12, 13);
    Time012 myTime32(12, 13);
    Time012 myTime33 = Time012{ 12, 13 };
    Time012 myTime34{ 12, 13 };
    Time012 myTime35 = { 12, 13 };
    func(12);
    func(12,18);
    cout << "-------------------------------------------------------" << endl;

    /*
        四、隐式转换 和 explicit
            - 编译系统，在底层干了很多我们所不知道和不了解的事。
            - 对于单参数的构造函数，一般都声明为 explicit，除非有特别原因。
    */
    cout << "四、隐式转换 和 explicit" << endl;
    //此段代码要去掉构造函数的 explicit 关键字，才能执行。
    //Time012 myTime40 = 14; //编译系统肯定有个行为，把14这个数字 转换成了一个Time类型。调用了单参数的构造函数。
    //Time012 myTime41 = (12, 13, 14, 16); //会把最后一数字 16 初始化到对象中。调用了单参数的构造函数。
    //func1(16); // 16被转换成了一个 临时的 Time012 对象，导致 func1的调用能够成功。调用了单参数的构造函数。
    //cout << "----------" << endl;

    //Time012 myTime100 = { 16 }; //这种写法是正常写法，带一个参数16，可以让系统明确的知道调用哪个构造函数。
    //Time012 myTime101 = 16; //含糊不清的写法，存在临时对象隐式转换。
    //func1(16); //也是含糊不清的写法，存在临时对象隐式转换。
    cout << "----------" << endl;

    /*
        是否可以强制系统，明确要求构造函数不能做隐式类型转换呢？
            - 可以，如果构造函数声明中带有explicit，则这个构造函数只能用于初始化和显示类型转换。
    */
    cout << "explicit - 带3个参数的构造函数" << endl;
    Time012 myTime50 = Time012(12, 13, 52);
    Time012 myTime52(12, 13, 52);
    Time012 myTime53 = Time012{ 12,13,52 };
    Time012 myTime54{ 12,13,52 };
    //Time012 myTime55 = { 12,13,52 }; //隐式类型转换（构造函数加了explicit，就不能使用隐式类型转换的写法来初始化对象了）
    cout << "----------" << endl;

    cout << "explicit - 带1个参数的构造函数" << endl;
    //下面这3中写法，都发生隐式类型转换，构造函数加了explicit，所以都无法执行成功。
    //Time012 myTime60 = { 16 };
    //Time012 myTime61 = 16; 
    //func1(16); 
    cout << "----------" << endl;
    cout << "-------------------------------------------------------" << endl;

    /*
        五、构造函数初始化列表
            - 提倡使用这种方式初始化
            - 显得更加专业
            - 不使用 构造函数初始化列表，系统也会给随机的初始值。然后我们在函数体内执行的其实是赋值语句，替换掉了系统给的随机初始值。这样比 使用构造函数初始化列表 多了一步赋值的操作。
    */
    cout << "四、隐式转换 和 explicit" << endl;
    Time012 myTime70 = Time012(12, 13, 52);
    cout << "-------------------------------------------------------" << endl;
}