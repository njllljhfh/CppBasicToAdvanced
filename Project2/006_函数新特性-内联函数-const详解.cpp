#include <iostream>
#include "006_head1.h"
using namespace std;

// 前置返回类型
void func1(int a, int); // 函数声明(函数原型)

void func1(int a, int) // 函数定义
{
    return;
}

//---------------------------------------------------------

// 后置返回类型
auto func2(int a, int b) -> void; // 函数声明

auto func2(int a, int b) -> void  // 函数定义
{
    return;
}

//---------------------------------------------------------

inline int myfunc(int testv) // 函数定义前加 inline，这个函数就变成了内联函数。
{
    return 1;
}

//---------------------------------------------------------

void funca()
{
    
}

void funcb()
{
    cout << "funcb() 调用 funca()" << endl;
    //return;  // 可以
    return funca(); // 可以
}
//---------------------------------------------------------

int* func3()
{
    int tmpvalue = 9;

    //不要返回局部变量的指针。
    //错误用法：tmpvalue 变量在栈上，函数执行后，该内存会被系统回收
    return &tmpvalue;  
}
//---------------------------------------------------------

int& func4()
{
    int tmpvalue = 9;
    cout << &tmpvalue << endl;
    return tmpvalue;
}

//---------------------------------------------------------
//没有形参
//int func5()
int func5(void)
{
    return 1;
}

//---------------------------------------------------------
//函数只声明，不调用
int func6();

//---------------------------------------------------------

struct Student006 { int num; };
// 形参传递引用
void func7(Student006& stu)
{
    stu.num = 1010;
}

//---------------------------------------------------------

// 同名函数重载
void func8(int i) 
{

}
void func8(float i)
{

}
void func8(int i, int j)
{

}

//---------------------------------------------------------

struct Student0061 { int num; };
// 在形参中增加 const，不能修改该形参指向对象的数据
//void func9(Student0061& stu)
void func9(const Student0061& stu)
{
    //stu.num = 1010; //错误
    cout << "调用func9()" << endl;
}

//---------------------------------------------------------

void func10(const int& a)
{
    cout << "调用func10()" << endl;
    return;
}
//---------------------------------------------------------


int main()
{
    //C++从基础到进阶-视频-06

    cout << "006_函数新特性-内联函数-const详解" << endl;
    cout << "-------------------------------------------------------" << endl;

    cout << "一、函数回顾与后置返回类型" << endl;
    /*
        一、函数回顾与后置返回类型
            函数定义中，形参如果在函数体内用不到，则可以不给形参变量名，只给其类型。

            把函数返回类型放到函数名前面，这种写法叫 前置返回类型。
                - c++11中，引入了 后置返回类型。在函数声明和定义中，把返回类型写在参数列表之后。
                    - 前面写auto，表示函数返回类型放到参数列表之后，放在参数列表之后的返回类型是通过 -> 开始的。

    */
    func1(12, 13);
    func2(12, 13);
    cout << "-------------------------------------------------------" << endl;

    cout << "二、内联函数" << endl;
    /*
        二、内联函数
            在函数定义前加 inline 关键字，这个函数就变成了内联函数。

            对函数体很小，调用又很频繁的函数。引入了 inline（内联函数）。
                1. inline 影响编译器，在编译阶段对 inline 这种函数进行处理，系统尝试将调用该函数的动作替换为函数本体。通过这种方式，来提升性能。
                2. inline 只是开发者对编译器的一个建议，编译器可以尝试去做，也可以不去做。这取决于编译器的诊断功能，也就是说，决定权在编译器，我们控制不了。
                3. 内联函数的定义要放在 头文件中。这样，需要用到内联函数的.cpp文件都能通过 #include 把内联函数的源代码 导入进来。
                    - 因为 inline 要用 函数本体源代码 来替换函数的调用。

            缺点：
                - 代码膨胀问题：建议内联函数的函数体尽量要小。

            注意：
                - 各种编译器对inline的处理各不相同。
                - 函数的函数体要尽量简单，代码尽可能少。循环、分支、递归等尽量不要出现在 inline 函数中。

            constexpr 函数 可以看成是 更严格的一种内联函数。

            #define宏展开也类似于inline（可以自己网上搜搜他们的异同，此处不展开讲）
    */

    int abc = myfunc(5);  // 编译器会尝试将此行处理为 int abc = 1; 这样就避免了函数调用的压栈和出栈。

    func3(1,2);  // 普通函数，在.h头文件中定义，在.cpp文件中定义。

    func4(3, 4); // 内联函数，函数的定义要放在 .h 头文件中。

    cout << "-------------------------------------------------------" << endl;

    cout << "三、函数杂合用法总结" << endl;
    /*
        三、函数杂合用法总结（特殊写法，以及错误写法）
            1. 函数返回类型为void，表示函数不返回任何类型。在一个返回类型为void的函数中，可以返回另一个返回值为void的函数的调用（请看 funcb 函数）。
            2. 函数返回指针和返回引用的情况。
            3. 函数没有形参，可以保持形参列表为空 int func5();，或者 int func5(void);
            4. 如果一个函数不调用的话，则该函数可以只有声明部分，没有定义部分。
            5. 普通函数，定义只能定义一次（定义放在 .cpp 文件中）。声明可以声明多次，一般函数定义的.cpp文件会 #include 自己的函数声明文件（.h文件）。
            6. 函数形参传引用，void func7(Student006& stu)，在c++中，更习惯用引用类型的形参来取代指针类型的形参。提倡在c++中，多使用引用类型的形参。
            7. c++中，函数允许同名，但是形参列表的参数类型 或 参数数量 应该有明显区别。
    */
    cout << "1.函数返回类型为void：" << endl;
    funcb();
    cout << "----------" << endl;

    cout << "2.错误用法，返回了局部变量的指针" << endl;
    //int* p = func3();
    //*p = 6; // 向一个已经不属于你的地址写了数据。
    cout << "----------" << endl;

    cout << "2.错误用法，返回了局部变量的引用" << endl;
    //int& k = func4();
    //cout << &k << endl;
    //k = 10;  // 向一个已经不属于你的地址写了数据。
    cout << "----------" << endl;

    cout << "2.函数内返回了局部变量的引用，调用方用 int类型 接收 int&引用类型的数据（这种写法是可以的）" << endl;
    int k = func4(); // 这种写法是可以的（很神奇，系统应该是做了特殊处理！），实际开发中一般不会这么写吧。
    cout << &k << endl;  // 地址与函数 func4 中的不同
    k = 10;  // 安全
    cout << "----------" << endl;

    cout << "6.形参传引用" << endl;
    Student006 stu7;
    stu7.num = 100;
    func7(stu7);
    cout << stu7.num << endl;  // 1010
    cout << "-------------------------------------------------------" << endl;

    /*
        四、const char*、 char const*、char* const
    */
    cout << "const char* p;   和   char const* p;  等价" << endl;
    // 常量指针
    //const char* p; // p指向的对象不能通过p来修改（对象的值不能通过p来修改）。p可以修改指向，重新指向其他对象。
    //const char* p;   和   char const* p;  等价
    char str[] = "I Love China!";
    const char* p; 
    //char const* p;
    p = str;
    //*p = 'Y';  // 语法错误。
    p++;
    str[0] = 'Y'; //这是可以的。
    cout << "----------" << endl;

    cout << "char* const p = str;" << endl;
    char str2[] = "I Love China!";
    // 指针常量
    // 定义的时候必须初始化。
    // p2一旦指向了一个对象后，就不可以再指向其他对象（即，不可以修改p2的指向）
    // p2可以修改它指向对象的内容
    char* const p2 = str2; 
    //p2++;  // 语法错误。
    *p2 = 'Y';
    cout << "----------" << endl;

    cout << "const char* const p = str;" << endl;
    // 下面这两种写法等价。
    // 定义的时候必须初始化。
    // p的指向不能改变，p指向的内容也不能通过p来改变。
    //const char* const p = str;
    //char const* const p = str;
    cout << "----------" << endl;

    int i = 100;
    const int& a = i;  // 代表不能通过 a 来修改 a 的内容。
    i = 200;
    //a = 300;  // 语法错误。

    //int& b = 31; // 错误
    const int& b2 = 31;
    cout << b2 << endl;
    //b2 = 45; //错误
    cout << "-------------------------------------------------------" << endl;

    cout << "五、函数形参中带 const" << endl;
    /*
        五、函数形参中带 const 
            好处：
                1. 可以防止无意中修改了形参值，导致实参值被无意修改。
                2. 实参类型可以更灵活。
    */
    Student0061 stu3;
    stu3.num = 100;
    func9(stu3);
    cout << stu3.num << endl; // 1010
    cout << "----------" << endl;

    // 常量引用
    const Student0061& def = stu3;
    func9(def); // 如果 func9 的形参中不加const，则此处无法调用 func9。（体现了const的灵活性）
    func10(13); // 如果 func10 的形参中不加const，则此处无法调用 func10。（体现了const的灵活性）

    cout << "-------------------------------------------------------" << endl;

    return 0;
}